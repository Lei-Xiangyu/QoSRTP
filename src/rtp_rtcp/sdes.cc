#include "sdes.h"

#include <sstream>

#include "../utils/byte_io.h"

using namespace qosrtp;
using namespace qosrtp::rtcp;

Sdes::Sdes() : chunks_buffer_length_(0){};

Sdes::~Sdes() = default;

uint32_t Sdes::ChunkSize(const Sdes::Chunk& chunk) {
  // Chunk:
  // SSRC/CSRC (4 bytes) | CNAME=1 (1 byte) | length (1 byte) | cname | padding.
  uint32_t chunk_payload_size = 4 + 1 + 1 + chunk.cname.size();
  uint32_t padding_size = 4 - (chunk_payload_size % 4);  // Minimum 1.
  return chunk_payload_size + padding_size;
}

std::unique_ptr<Result> Sdes::StorePacket(const CommonHeader& packet) {
  if (kPacketType != packet.type()) {
    return Result::Create(-1, "The type of rtcp is not sdes.");
  }
  if (packet.payload_size_bytes() % 4 != 0) {
    std::stringstream result_description;
    result_description << "Invalid payload size " << packet.payload_size_bytes()
                       << " bytes for a valid Sdes packet. Size should be"
                          " multiple of 4 bytes";
    return Result::Create(-1, result_description.str());
  }
  uint8_t number_of_chunks = packet.count();
  std::vector<Chunk> chunks;  // Read chunk into temporary array, so that in
                              // case of an error original array would stay
                              // unchanged.
  chunks.resize(number_of_chunks);
  uint32_t chunks_buffer_length = 0;
  const uint8_t* const payload_end =
      packet.payload() + packet.payload_size_bytes();
  const uint8_t* looking_at = packet.payload();
  for (uint32_t i = 0; i < number_of_chunks;) {
    // Each chunk consumes at least 8 bytes.
    if (payload_end - looking_at < 8) {
      std::stringstream result_description;
      result_description << "Not enough space left for chunk #" << (i + 1);
      return Result::Create(-1, result_description.str());
    }
    chunks[i].ssrc = ByteReader<uint32_t>::ReadBigEndian(looking_at);
    looking_at += sizeof(uint32_t);
    bool cname_found = false;

    uint8_t item_type;
    while ((item_type = *(looking_at++)) != kTerminatorTag) {
      if (looking_at >= payload_end) {
        std::stringstream result_description;
        result_description << "Unexpected end of packet while reading chunk #"
                           << (i + 1) << ". Expected to find size of the text.";
        return Result::Create(-1, result_description.str());
      }
      uint8_t item_length = *(looking_at++);
      const uint32_t kTerminatorSize = 1;
      if (looking_at + item_length + kTerminatorSize > payload_end) {
        std::stringstream result_description;
        result_description << "Unexpected end of packet while reading chunk #"
                           << (i + 1) << ". Expected to find text of size "
                           << item_length;
        return Result::Create(-1, result_description.str());
      }
      if (item_type == kCnameTag) {
        if (cname_found) {
          std::stringstream result_description;
          result_description << "Found extra CNAME for same ssrc in chunk #"
                             << (i + 1);
          return Result::Create(-1, result_description.str());
        }
        cname_found = true;
        chunks[i].cname.assign(reinterpret_cast<const char*>(looking_at),
                               item_length);
      }
      looking_at += item_length;
    }
    if (cname_found) {
      // chunks_buffer_length calculates length of the packet that would be generated by
      // Build/Create functions. Adjust it same way WithCName function does.
      chunks_buffer_length += ChunkSize(chunks[i]);
      ++i;
    } else {
      // RFC states CNAME item is mandatory.
      // But same time it allows chunk without items.
      // So while parsing, ignore all chunks without cname,
      // but do not fail the parse.
      --number_of_chunks;
      chunks.resize(number_of_chunks);
    }
    // Adjust to 32bit boundary.
    looking_at += (payload_end - looking_at) % 4;
  }
  chunks_ = std::move(chunks);
  chunks_buffer_length_ = chunks_buffer_length;
  return Result::Create();
}

std::unique_ptr<Result> Sdes::AddCName(uint32_t ssrc, std::string cname) {
  if (cname.length() > (uint8_t)0xff) {
    return Result::Create(-1, "The length of cname must be shorter than 255.");
  }
  if (chunks_.size() >= kMaxNumberOfChunks) {
    return Result::Create(-1, "Max SDES chunks reached.");
  }
  Chunk chunk;
  chunk.ssrc = ssrc;
  chunk.cname = std::move(cname);
  chunks_.push_back(chunk);
  chunks_buffer_length_ += ChunkSize(chunk);
  return Result::Create();
}

uint32_t Sdes::BlockLength() const {
  return chunks_buffer_length_ + kHeaderLength;
}

std::unique_ptr<Result> Sdes::LoadPacket(uint8_t* packet, uint32_t* pos,
                                         uint32_t max_length) const {
  if (*pos + BlockLength() > max_length) {
    return Result::Create(-1,
                          "The remaining buffer space is less than the length "
                          "of the loaded packet");
  }
  const uint32_t index_end = *pos + BlockLength();
  CreateHeader(chunks_.size(), kPacketType,
               (BlockLength() - kHeaderLength) / sizeof(uint32_t), packet, pos);
  for (const Sdes::Chunk& chunk : chunks_) {
    ByteWriter<uint32_t>::WriteBigEndian(&packet[*pos + 0], chunk.ssrc);
    ByteWriter<uint8_t>::WriteBigEndian(&packet[*pos + 4], kCnameTag);
    ByteWriter<uint8_t>::WriteBigEndian(
        &packet[*pos + 5], static_cast<uint8_t>(chunk.cname.size()));
    memcpy(&packet[*pos + 6], chunk.cname.data(), chunk.cname.size());
    *pos += (6 + chunk.cname.size());
    // In each chunk, the list of items must be terminated by one or more null
    // octets. The next chunk must start on a 32-bit boundary.
    // CNAME (1 byte) | length (1 byte) | name | padding.
    uint32_t padding_size = 4 - ((6 + chunk.cname.size()) % 4);
    const int kPadding = 0;
    memset(packet + *pos, kPadding, padding_size);
    *pos += padding_size;
  }
  return Result::Create();
}
